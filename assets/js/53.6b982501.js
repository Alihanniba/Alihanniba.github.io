(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{569:function(_,e,v){"use strict";v.r(e);var o=v(6),a=Object(o.a)({},(function(){var _=this,e=_.$createElement,v=_._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/plp92.jpg",alt:""}})]),_._v(" "),v("blockquote",[v("p",[_._v("题图：pixabay")])]),_._v(" "),v("h2",{attrs:{id:"_0、先回顾一条语句的写入流程是怎样子的-经过了哪些环节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0、先回顾一条语句的写入流程是怎样子的-经过了哪些环节"}},[_._v("#")]),_._v(" 0、先回顾一条语句的写入流程是怎样子的？经过了哪些环节？")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/eu3iw.png",alt:""}})]),_._v(" "),v("h2",{attrs:{id:"_1、为什么要讲-change-buffer-和-redo-log-呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、为什么要讲-change-buffer-和-redo-log-呢"}},[_._v("#")]),_._v(" 1、为什么要讲 "),v("code",[_._v("change buffer")]),_._v(" 和 "),v("code",[_._v("redo log")]),_._v(" 呢？")]),_._v(" "),v("p",[_._v("因为我在看这块相关的东西的时候，第一遍和第二遍都会把 "),v("code",[_._v("change buffer")]),_._v(" 和 "),v("code",[_._v("redo log")]),_._v(" 搞混。 "),v("code",[_._v("binlog")]),_._v(" 一般大家都知道是干嘛的，数据同步嘛。 "),v("code",[_._v("redo log")]),_._v(" 是干嘛的呢？这是一块内存空间还是磁盘空间？为什么还需要 "),v("code",[_._v("change buffer")]),_._v(" ？它是为谁承载的呢？这几个东西在初接触时比较容易头晕。")]),_._v(" "),v("h2",{attrs:{id:"_2、名词解释1-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、名词解释1-0"}},[_._v("#")]),_._v(" 2、名词解释1.0")]),_._v(" "),v("h3",{attrs:{id:"_2-1、什么是两阶段提交"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、什么是两阶段提交"}},[_._v("#")]),_._v(" 2.1、什么是两阶段提交？")]),_._v(" "),v("p",[_._v("我们来看下一条语句执行的细节")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/wiq9b.png",alt:"mysql核心剖析系列-两阶段提交"}})]),_._v(" "),v("p",[_._v("两阶段提交最好的理解就是从字面意思去理解，数据分为两个阶段提交写入。第一次写，第二次确认。")]),_._v(" "),v("h3",{attrs:{id:"_2-2、什么是-redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、什么是-redo-log"}},[_._v("#")]),_._v(" 2.2、什么是 "),v("code",[_._v("redo log")]),_._v(" ？")]),_._v(" "),v("h4",{attrs:{id:"_2-2-1、名词解释"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1、名词解释"}},[_._v("#")]),_._v(" 2.2.1、名词解释")]),_._v(" "),v("p",[_._v("这里说了。"),v("strong",[v("a",{attrs:{href:"https://mp.weixin.qq.com/s/xas_fp0gqpVoIuT0JZw3-g",target:"_blank",rel:"noopener noreferrer"}},[_._v("【Mysql核心剖析系列】MVCC是怎么保障一致性视图的？"),v("OutboundLink")],1)])]),_._v(" "),v("h4",{attrs:{id:"_2-2-2、特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2、特性"}},[_._v("#")]),_._v(" 2.2.2、特性")]),_._v(" "),v("p",[v("code",[_._v("redo log")]),_._v(" 是固定大小的，且是可以设置的，同时是顺序写入模式。有几个关键的配置项：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("innodb_log_buffer_zise")]),_._v("。缓冲区大小")]),_._v(" "),v("li",[v("code",[_._v("innodb_log_file_in_group")]),_._v("。文件组数量")]),_._v(" "),v("li",[v("code",[_._v("innodb_log_file_size")]),_._v("。文件大小")])]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/mp79e.png",alt:"image-20210902080224041"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/b1vi5.png",alt:"image-20210902080316236"}})]),_._v(" "),v("p",[v("code",[_._v("redo log")]),_._v(" 的写入还有一个特征就是环形覆盖。"),v("code",[_._v("redo log")]),_._v(" 的容量总是有限的，如果写满了咋办呢？继续往下看")]),_._v(" "),v("h3",{attrs:{id:"_2-3、什么是-redo-log-buffer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3、什么是-redo-log-buffer"}},[_._v("#")]),_._v(" 2.3、什么是 "),v("code",[_._v("redo log buffer")]),_._v(" ？")]),_._v(" "),v("p",[v("code",[_._v("redo log buffer")]),_._v(" 是承接在 "),v("code",[_._v("redo log")]),_._v(" 前面的一块内存缓冲区域。引擎写 "),v("code",[_._v("redo log")]),_._v(" 并不会直接写磁盘，而是写 "),v("code",[_._v("redo log buffer")]),_._v("，后期再由 "),v("code",[_._v("redo log buffer")]),_._v(" 刷到磁盘。这里的 "),v("code",[_._v("redo log buffer")]),_._v(" 是用户空间的缓冲区，写磁盘之前还经过了一层内核缓冲区（"),v("code",[_._v("os buffer")]),_._v("）。写磁盘的流程是这样子的:")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/u8b2h.png",alt:"d"}})]),_._v(" "),v("p",[v("strong",[_._v("为什么这么做？")]),_._v(" 还是为了追求1、写速度；2、同步改为了异步。同时写buffer刷磁盘也支持几种策略（通过参数 "),v("code",[_._v("innodb_flush_log_at_trx_commit")]),_._v(" 配置）：")]),_._v(" "),v("ol",[v("li",[_._v("延迟写，实时刷。固定每秒一次写  "),v("code",[_._v("os buffer")]),_._v("  并同步刷磁盘")]),_._v(" "),v("li",[_._v("实时写，实时刷。每次写  "),v("code",[_._v("redo log buffer")]),_._v(" 都会 写  "),v("code",[_._v("os buffer")]),_._v(" 且同步刷磁盘")]),_._v(" "),v("li",[_._v("实时写，延迟刷。每次写  "),v("code",[_._v("os buffer")]),_._v("  并每秒一次刷磁盘")])]),_._v(" "),v("h2",{attrs:{id:"_3、为什么要有两阶段提交"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、为什么要有两阶段提交"}},[_._v("#")]),_._v(" 3、为什么要有两阶段提交？")]),_._v(" "),v("h3",{attrs:{id:"_3-1、两阶段提交解决了什么问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1、两阶段提交解决了什么问题"}},[_._v("#")]),_._v(" 3.1、两阶段提交解决了什么问题？")]),_._v(" "),v("p",[v("strong",[v("code",[_._v("crash safe")])]),_._v("。两阶段、三阶段都是为了解决分布式事务中的数据一致性问题，既然是分布式事务，那肯定是分布式的，如果是单体的，那就用不上这玩意儿。比如说我就起一个 mysql 实例，用不上 "),v("code",[_._v("binlog")]),_._v("。 "),v("code",[_._v("redo log")]),_._v(" 写一次就可以了。数据库崩溃重启后 仅仅用 "),v("code",[_._v("redo log")]),_._v(" 记录来恢复即可。")]),_._v(" "),v("p",[_._v("两阶段提交的作用是为了保证 "),v("code",[_._v("redo log")]),_._v(" 跟 "),v("code",[_._v("binlog")]),_._v(" 数据的一致性（并不是完全一致，会有逻辑判断是往前补还是往后退）。防止数据库崩溃重试恢复过程中的数据不一致。因为主库是用 "),v("code",[_._v("redo log")]),_._v(" 来恢复，从库是用 "),v("code",[_._v("binlog")]),_._v(" 来同步的。")]),_._v(" "),v("h3",{attrs:{id:"_3-2、redo-log-是怎么保证-crash-safe-的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2、redo-log-是怎么保证-crash-safe-的"}},[_._v("#")]),_._v(" 3.2、"),v("code",[_._v("redo log")]),_._v(" 是怎么保证 "),v("code",[_._v("crash safe")]),_._v(" 的？")]),_._v(" "),v("h4",{attrs:{id:"_3-2-1、redo-log-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1、redo-log-原理"}},[_._v("#")]),_._v(" 3.2.1、"),v("code",[_._v("redo log")]),_._v(" 原理")]),_._v(" "),v("p",[_._v("执行 "),v("code",[_._v("show engine innodb status")]),_._v(" 可以看到 "),v("code",[_._v("redo log")]),_._v(" 的信息。")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("Log sequence number")]),_._v(" ：当前 "),v("code",[_._v("redo log")]),_._v(" 的最新 "),v("code",[_._v("LSN")])]),_._v(" "),v("li",[v("code",[_._v("Log flushed up to")]),_._v(" ：当前已经刷新到磁盘上 "),v("code",[_._v("redo log")]),_._v(" 的 "),v("code",[_._v("LSN")])]),_._v(" "),v("li",[v("code",[_._v("Last checkpoint at")]),_._v(" ：最后一次检查点的 "),v("code",[_._v("LSN")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/oxq2h.png",alt:"image-20210902143232591"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/it92i.png",alt:"mysql核心剖析系列-redo log .png"}})]),_._v(" "),v("p",[v("code",[_._v("redo log")]),_._v(" 日志文件默认是两个，可以设置。InnoDB 通过 "),v("code",[_._v("Log Sequence Number")]),_._v(" , "),v("code",[_._v("LSN")]),_._v(" 来用于记录日志序号，"),v("code",[_._v("LSN")]),_._v(" 几乎无处不在。通过它可以定位到日志文件中的位置。")]),_._v(" "),v("p",[_._v("上图有两个点哈，因为 "),v("code",[_._v("redo log")]),_._v(" 大小是固定的，所以总有写满的时候。那写满了怎么办，总不能直接把数据丢了吧。所有就有了这个类似于环的结构。日志一直写，当写完 "),v("code",[_._v("ib_logfile1")]),_._v(" 最后一个坑之后，会继续从 "),v("code",[_._v("ib_logfile0")]),_._v(" 的首位开始写。那原来 "),v("code",[_._v("ib_logfile0")]),_._v(" 首位的数据是不是得删掉，那么怎么知道要删哪些数据？这就是 "),v("code",[_._v("checkpoint")]),_._v(" 要做的事儿。 "),v("code",[_._v("checkpoint")]),_._v(" 表示一个临界点，它后面的数据已经不重要了（已经落到库磁盘了），可以随意处置。 "),v("code",[_._v("redo log")]),_._v(" 通过这两个点来实现无限续写，但是有个问题：")]),_._v(" "),v("ol",[v("li",[_._v("如果 "),v("code",[_._v("checkpoint")]),_._v(" 被最新的日志赶上了呢，就是数据还没写到磁盘，可能在 "),v("code",[_._v("change buffer")]),_._v(" 里，或者在 "),v("code",[_._v("buffer pool")]),_._v(" 里，但还没落盘。这时候如果被覆盖了，奔溃后是没法恢复数据的。所以当 "),v("code",[_._v("checkpoint")]),_._v(" 被最新的日志追上的时候，会停下来，推着 "),v("code",[_._v("checkpoint")]),_._v(" 继续往前走。")]),_._v(" "),v("li",[_._v("可以理解为，如果被赶上了，最新的数据就不允许写了，hang住，先让子弹飞一会儿。")])]),_._v(" "),v("p",[v("code",[_._v("LSN")]),_._v(" 另一个作用是在奔溃恢复时会比较 "),v("code",[_._v("redo log")]),_._v(" 与 库里数据页的 "),v("code",[_._v("LSN")]),_._v(" 点位来修复数据。")]),_._v(" "),v("h4",{attrs:{id:"_3-2-2、根据下面这两张图-举几种case"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2、根据下面这两张图-举几种case"}},[_._v("#")]),_._v(" 3.2.2、根据下面这两张图，举几种case：")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/cuwca.png",alt:"mysql核心剖析系列-crash safe.png"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/j645y.png",alt:"mysql核心剖析系列-crash safe 恢复.png"}})]),_._v(" "),v("ol",[v("li",[_._v("在 "),v("code",[_._v("step 1")]),_._v(" 处挂了。 "),v("code",[_._v("redo log")]),_._v(" 没有提交， "),v("code",[_._v("binlog")]),_._v(" 也没写；事务回滚，对数据没影响")]),_._v(" "),v("li",[_._v("在 "),v("code",[_._v("step 2")]),_._v(" 处挂了。这里有2种情况：\n"),v("ol",[v("li",[v("code",[_._v("binlog")]),_._v(" 写了 "),v("code",[_._v("binlog cache")]),_._v(" ，还没刷到磁盘； "),v("code",[_._v("redo log")]),_._v(" 还没提交。当崩溃恢复时，先判断  "),v("code",[_._v("redo log")]),_._v(" 的 "),v("code",[_._v("pre")]),_._v(" 标识，再根据 "),v("code",[_._v("xid")]),_._v(" 去 "),v("code",[_._v("binlog")]),_._v(" 里找，发现没有，回滚事务。")]),_._v(" "),v("li",[v("code",[_._v("binlog")]),_._v(" 已经刷到磁盘； "),v("code",[_._v("redo log")]),_._v(" 还没提交。当崩溃恢复时，先判断 "),v("code",[_._v("redo log")]),_._v(" 的 "),v("code",[_._v("pre")]),_._v(" 标识，再根据 "),v("code",[_._v("xid")]),_._v(" 去 "),v("code",[_._v("binlog")]),_._v(" 里找，发现存在记录，提交事务。 "),v("code",[_._v("redo log")]),_._v("  commit")])])]),_._v(" "),v("li",[_._v("在 "),v("code",[_._v("step 3")]),_._v(" 处挂了。这里也有2种情况：\n"),v("ol",[v("li",[v("code",[_._v("binlog")]),_._v(" 已经刷磁盘； "),v("code",[_._v("redo log")]),_._v("  commit 写了 "),v("code",[_._v("redo log buffer")]),_._v(" ，还没刷到磁盘；先判断 "),v("code",[_._v("redo log")]),_._v(" 的 "),v("code",[_._v("pre")]),_._v(" 标识，再根据 "),v("code",[_._v("xid")]),_._v(" 去 "),v("code",[_._v("binlog")]),_._v(" 里找，发现存在记录，提交事务。 "),v("code",[_._v("redo log")]),_._v("  commit")]),_._v(" "),v("li",[v("code",[_._v("binlog")]),_._v("  已经刷磁盘； "),v("code",[_._v("redo log")]),_._v("  刷磁盘。判断 "),v("code",[_._v("redo log")]),_._v("  的 "),v("code",[_._v("commit")]),_._v(" 标识；直接提交事务。")])])])]),_._v(" "),v("p",[_._v("以上的case就是不管在那一层崩溃都能依靠 "),v("code",[_._v("redo log")]),_._v(" 来保证主从数据一致性以及客户端感知一致性。但是：")]),_._v(" "),v("p",[v("strong",[_._v("当数据写到 buffer pool 之后，刷盘之前挂了咋整？")])]),_._v(" "),v("h3",{attrs:{id:"_3-3、持久化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3、持久化"}},[_._v("#")]),_._v(" 3.3、持久化")]),_._v(" "),v("h2",{attrs:{id:"_4、名词解释2-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、名词解释2-0"}},[_._v("#")]),_._v(" 4、名词解释2.0")]),_._v(" "),v("h3",{attrs:{id:"_4-1、什么是-change-buffer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1、什么是-change-buffer"}},[_._v("#")]),_._v(" 4.1、什么是 "),v("code",[_._v("change buffer")]),_._v(" ？")]),_._v(" "),v("p",[v("code",[_._v("change buffer")]),_._v(" 是一块缓冲区，存储的就是最新的数据变更。它主要解决的是 "),v("code",[_._v("随机读磁盘IO")]),_._v(" 消耗大的问题。为什么是随机读呢？")]),_._v(" "),v("p",[_._v("看着文章第二张图讲。如果没有 "),v("code",[_._v("change buffer")]),_._v(" ，当有一条更新语句进来对某条数据进行修改时，需要找到这条数据，优先从 "),v("code",[_._v("buffer pool")]),_._v(" 中找，不存在则从磁盘获取。将数据页从磁盘读入 "),v("code",[_._v("buffer pool")]),_._v(" 涉及随机 IO 访问，这是数据库中成本最高的操作之一。所以有了这么一块缓冲区之后，针对某些写入或修改操作，直接把数据缓存在 "),v("code",[_._v("change buffer")]),_._v(" 中。当下次查询的时候再从磁盘读出原始数据，将原始数据和 "),v("code",[_._v("change buffer")]),_._v(" 中的改动做 merge 之后返回。省去的是写操作时可能涉及到的磁盘IO操作。")]),_._v(" "),v("p",[v("code",[_._v("change buffer")]),_._v(" 虽然名上是 "),v("code",[_._v("buffer")]),_._v("。但其实它是可以持久化的，它持久化的地方默认是 "),v("code",[_._v("ibdata1")]),_._v("  共享空间表中（看上文件图）。因为为了保证数据的一致性")]),_._v(" "),v("p",[v("strong",[_._v("同时， "),v("code",[_._v("change buffer")]),_._v(" 也是需要写 "),v("code",[_._v("redo log")]),_._v(" 的。所以 "),v("code",[_._v("redo log")]),_._v(" 里不仅有针对普通数据页的改动记录，也有 "),v("code",[_._v("change buffer")]),_._v(" 的记录。")])]),_._v(" "),v("p",[_._v("然后说到 "),v("code",[_._v("change buffer")]),_._v(" 就不得不说到 "),v("code",[_._v("buffer pool")]),_._v(" 。顾名思义，缓冲池。我们在做项目工程的时候，遇到高并发的场景一般都会在db前面加一层 redis 扛一波，防止大量请求直接把 db 打挂，那么 redis 在这里充当了缓冲的作用。 "),v("code",[_._v("buffer pool")]),_._v(" 也是类似，server 层的查请求过来会先打在 "),v("code",[_._v("buffer pool")]),_._v(" 上，如果 "),v("code",[_._v("buffer pool")]),_._v(" 不存在对应的数据才会去查磁盘，否则直接取 "),v("code",[_._v("buffer pool")]),_._v(" 中的数据返回了。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/g0o34.png",alt:"mysql核心剖析系列-缓冲.png"}})]),_._v(" "),v("p",[_._v("那么 "),v("code",[_._v("change buffer")]),_._v(" 与 "),v("code",[_._v("buffer pool")]),_._v(" 是什么关系呢？")]),_._v(" "),v("p",[_._v("如上图。"),v("strong",[_._v("包含关系")])]),_._v(" "),v("p",[v("code",[_._v("change buffer")]),_._v(" 是 "),v("code",[_._v("buffer pool")]),_._v(" 里的一块区域")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("innodb_change_buffer_max_size")]),_._v(" 表示 "),v("code",[_._v("change buffer")]),_._v(" 最大占 "),v("code",[_._v("buffer pool")]),_._v(" 的百分比，默认为 25%")])]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/095ql.png",alt:"image-20210919170911021"}})]),_._v(" "),v("p",[_._v("下面看一下 执行一条语句在 "),v("code",[_._v("buffer")]),_._v(" 这块的细节")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://share.alihanniba.com/mac/aw1ne.png",alt:"mysql核心剖析系列-缓冲流程.drawio.png"}})]),_._v(" "),v("p",[_._v("我们来举几种场景：")]),_._v(" "),v("ol",[v("li",[_._v("一条简单的更新语句。"),v("code",[_._v('where name = "花一个无所"')]),_._v(" "),v("ol",[v("li",[_._v("判断 "),v("code",[_._v("buffer pool")]),_._v(" 中是否存在这条数据")]),_._v(" "),v("li",[_._v("若存在则直接更新 "),v("code",[_._v("buffer pool")])]),_._v(" "),v("li",[_._v("否则 add "),v("code",[_._v("change buffer")])]),_._v(" "),v("li",[_._v("写 "),v("code",[_._v("redo log")])])])]),_._v(" "),v("li",[_._v("一条根据唯一健更新的语句。"),v("code",[_._v("where uniqId = 7")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("判断 "),v("code",[_._v("buffer pool")]),_._v("  中是否存在这条数据")])]),_._v(" "),v("li",[v("p",[_._v("若存在则直接更新 "),v("code",[_._v("buffer pool")])])]),_._v(" "),v("li",[v("p",[_._v("否则查磁盘")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("如果存在则 load 进 buffer pool\n否则返回错误\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br")])])]),_._v(" "),v("li",[v("p",[_._v("更新 "),v("code",[_._v("buffer pool")])])]),_._v(" "),v("li",[v("p",[_._v("写 "),v("code",[_._v("redo log")])])])])]),_._v(" "),v("li",[_._v("一条简单的查询语句。"),v("code",[_._v('select * from name = "花一个无所"')]),_._v(" "),v("ol",[v("li",[v("p",[_._v("判断 "),v("code",[_._v("buffer pool")]),_._v(" 中是否存在这条数据")])]),_._v(" "),v("li",[v("p",[_._v("如果不存在则查磁盘")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("如果存在则 load 进 buffer pool\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])])]),_._v(" "),v("li",[v("p",[_._v("判断 "),v("code",[_._v("change buffer")]),_._v(" 中是否有这条数据")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("如果存在则 merge 进 buffer pool\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])])]),_._v(" "),v("li",[v("p",[_._v("返回 merge 之后的数据")])])])])]),_._v(" "),v("h2",{attrs:{id:"_5、为什么要有-change-buffer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、为什么要有-change-buffer"}},[_._v("#")]),_._v(" 5、为什么要有 "),v("code",[_._v("change buffer")]),_._v("？")]),_._v(" "),v("h3",{attrs:{id:"_5-1、change-buffer-解决了什么问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1、change-buffer-解决了什么问题"}},[_._v("#")]),_._v(" 5.1、"),v("code",[_._v("change buffer")]),_._v(" 解决了什么问题？")]),_._v(" "),v("p",[_._v("将数据页从磁盘读入内存中涉及随机 IO 访问，这也是数据库里面成本最高的操作之一，而利用写缓存（ "),v("code",[_._v("change buffer")]),_._v(" ）可以减少 IO 操作，从而提升数据库性能。")]),_._v(" "),v("p",[v("strong",[_._v("那为啥唯一索引不能利用 "),v("code",[_._v("change buffer")]),_._v(" 呢？")])]),_._v(" "),v("p",[_._v("上面流程里面。唯一索引在做 insert 或者 update 的时候，需要先判断索引记录的唯一性，所以肯定要先拿到最新的记录。即会将磁盘数据页加载到内存，然后判断。所以既然都加载到内存了，那我直接操作内存就好了，就不用搭理 "),v("code",[_._v("change buffer")]),_._v(" 了，不然还得 merge 啥的多麻烦。")]),_._v(" "),v("h3",{attrs:{id:"_5-2、-change-buffer-干掉可不可以"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2、-change-buffer-干掉可不可以"}},[_._v("#")]),_._v(" 5.2、 "),v("code",[_._v("change buffer")]),_._v(" 干掉可不可以？")]),_._v(" "),v("p",[v("code",[_._v("change buffer")]),_._v(" 本身就是一个可选项。")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("innodb_change_buffering")]),_._v(" 参数用来控制对哪些操作启用 "),v("code",[_._v("change buffer")]),_._v(" 功能，默认是： "),v("code",[_._v("all")]),_._v("。**")])]),_._v(" "),v("p",[v("strong",[v("code",[_._v("innodb_change_buffering")]),_._v(" 参数拢共有以下几种选择：")])]),_._v(" "),v("ul",[v("li",[_._v("all。默认值。开启buffer")]),_._v(" "),v("li",[_._v("none。不开启 change buffer")]),_._v(" "),v("li",[_._v("inserts。只是开启 buffer insert 操作")]),_._v(" "),v("li",[_._v("deletes。只是开启 delete-marking 操作")]),_._v(" "),v("li",[_._v("changes。开启 buffer insert 操作和 delete-marking 操作")]),_._v(" "),v("li",[_._v("purges。对只是在后台执行的物理删除操作开启 buffer 功能")])]),_._v(" "),v("p",[_._v("不开启的影响就是回到了随机读。当 "),v("code",[_._v("buffer pool")]),_._v(" 中不存在此数据时，写入操作时会先从磁盘读出数据 load 进 "),v("code",[_._v("buffer pool")]),_._v(" ，再进行下面的操作。每次都是这样，对逻辑及数据准确性没有影响，只是影响性能。")]),_._v(" "),v("h3",{attrs:{id:"_5-3、持久化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3、持久化"}},[_._v("#")]),_._v(" 5.3、持久化")]),_._v(" "),v("h4",{attrs:{id:"_5-3-1、-change-buffer-持久化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-1、-change-buffer-持久化"}},[_._v("#")]),_._v(" 5.3.1、 "),v("code",[_._v("change buffer")]),_._v(" 持久化")]),_._v(" "),v("p",[v("strong",[v("code",[_._v("change buffer")]),_._v(" 是用来 更新 非主键/唯一索引的二级索引B+树的。"),v("code",[_._v("redolog")]),_._v(" 是保障 "),v("code",[_._v("crash-safe")]),_._v(" 的。")])]),_._v(" "),v("p",[v("code",[_._v("change buffer")]),_._v(" 为啥要持久化？")]),_._v(" "),v("p",[_._v("看看不持久化会有什么影响。")]),_._v(" "),v("p",[v("code",[_._v("change buffer")]),_._v(" 插入时需要写 "),v("code",[_._v("redo log")]),_._v("。当宕机时， "),v("code",[_._v("change buffer")]),_._v(" 丢失，"),v("code",[_._v("redo log")]),_._v(" 记录了数据的完整修改记录，恢复时根据 "),v("code",[_._v("redo log")]),_._v(" 重建 "),v("code",[_._v("change buffer")]),_._v(" 。感觉不用持久化也可以啊")]),_._v(" "),v("p",[_._v("个人见解：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("change buffer")]),_._v(" 是有容量限制的。当内存容量用完了落盘来留出空间应对新操作。")]),_._v(" "),v("li",[v("code",[_._v("redo log")]),_._v(" 保证的是原数据的准确性， "),v("code",[_._v("change buffer")]),_._v(" 保证的是索引页的准确性。落盘是为了数据的一致性")])]),_._v(" "),v("h4",{attrs:{id:"_5-3-2、刷脏页"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-2、刷脏页"}},[_._v("#")]),_._v(" 5.3.2、刷脏页")]),_._v(" "),v("p",[_._v("什么叫刷脏页？")]),_._v(" "),v("p",[_._v("某条数据在内存中存在。这时有一个更新语句过来修改内存 然后返回。此时内存里的数据跟磁盘不一致， 内存中的数据就是脏数据。因为数据记录是以页为单位，就称脏页。")]),_._v(" "),v("p",[_._v("将 "),v("code",[_._v("buffer pool")]),_._v(" 中的脏数据定期的应用到原数据页得到最新结果的过程称为刷脏页。把磁盘数据读到内存，然后 merge  "),v("code",[_._v("change buffer")]),_._v(" 会写磁盘。此时，磁盘和内存里的数据都是新的正确的数据。")]),_._v(" "),v("p",[_._v("有哪几种场景会触发刷脏页？")]),_._v(" "),v("ol",[v("li",[_._v("查数据时。磁盘存在、 "),v("code",[_._v("change buffer")]),_._v("  存在 且 "),v("code",[_._v("buffer pool")]),_._v(" 存在")]),_._v(" "),v("li",[_._v("后台定期刷")]),_._v(" "),v("li",[_._v("数据库关闭")])]),_._v(" "),v("h2",{attrs:{id:"_6、引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6、引用"}},[_._v("#")]),_._v(" 6、引用")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://time.geekbang.org/column/intro/139",target:"_blank",rel:"noopener noreferrer"}},[_._v("极客时间《MySQL实战45讲》"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("a",{attrs:{href:"http://mysql.taobao.org/monthly/",target:"_blank",rel:"noopener noreferrer"}},[_._v("数据库内核月报"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("https://www.modb.pro/db/62466")]),_._v(" "),v("h3",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[_._v("#")])]),_._v(" "),v("img",{staticClass:"wechat-num",attrs:{src:"http://share.alihanniba.com/mac/490lq.png"}})])}),[],!1,null,null,null);e.default=a.exports}}]);