(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{533:function(t,v,_){"use strict";_.r(v);var a=_(6),i=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[_("img",{attrs:{src:"http://share.alihanniba.com/mac/2021-05-15-154637.jpg",alt:"http://share.alihanniba.com/mac/2021-05-15-154637.jpg"}})]),t._v(" "),_("blockquote",[_("p",[t._v("题图：pixabay")])]),t._v(" "),_("h3",{attrs:{id:"理解原型对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#理解原型对象"}},[t._v("#")]),t._v(" 理解原型对象")]),t._v(" "),_("ul",[_("li",[t._v("prototype 通过调用构造函数创建的对象实例的原型对象")]),t._v(" "),_("li",[t._v("constructor 包含一个指向prototype 属性所在函数的指针（可以通过实例对象访问，不能通过实例对象重写）")])]),t._v(" "),_("h3",{attrs:{id:"原型链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),_("ul",[_("li",[t._v("构造函数、原型和实例的关系\n"),_("ul",[_("li",[t._v("每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。")]),t._v(" "),_("li",[t._v("假如让原型对象等于另一个类型的实例。此时，原型对象将包含一个指向另一个原型的指针，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成额实例与原型的链条，这就是所谓的原型链的基本概念。")])])])]),t._v(" "),_("h3",{attrs:{id:"闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),_("ul",[_("li",[t._v("闭包是指有权访问另一个函数作用域中的变量的函数")]),t._v(" "),_("li",[t._v("闭包只能取得包含函数中任何变量的最后一个值（for循环事件）\n"),_("ul",[_("li",[t._v("因为每个函数的作用域链中都保存这外层函数的活动对象，所以他们引用的都是同一个变量i，当外层函数返回后，变量 i 的值为10。")]),t._v(" "),_("li",[t._v("解决办法是：创建另一个匿名函数强制让闭包的行为符合预期")])])]),t._v(" "),_("li",[t._v("闭包中的this通常指向window，在通过apply（）和call（）改变函数执行环节的情况下，this会指向其他对象")]),t._v(" "),_("li",[t._v("如何引起内存泄漏：在闭包中保存一个HTML元素")])]),t._v(" "),_("h3",{attrs:{id:"隐式原型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隐式原型"}},[t._v("#")]),t._v(" 隐式原型")]),t._v(" "),_("ul",[_("li",[t._v("每个函数function都有一个prototype")]),t._v(" "),_("li",[t._v("每个对象都有一个proto")]),t._v(" "),_("li",[t._v("每个对象都有一个proto属性，指向创建该对象的函数的prototype")]),t._v(" "),_("li",[t._v("Object.prototype确实一个特例——它的proto指向的是null，切记切记")])]),t._v(" "),_("h3",{attrs:{id:"instanceof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#instanceof"}},[t._v("#")]),t._v(" instanceof")]),t._v(" "),_("ul",[_("li",[t._v("Instanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。")]),t._v(" "),_("li",[t._v("instanceof表示的就是一种继承关系，或者原型链的结构")])]),t._v(" "),_("h3",{attrs:{id:"继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),_("ul",[_("li",[t._v("访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。")])]),t._v(" "),_("h3",{attrs:{id:"执行上下文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),_("ul",[_("li",[t._v("函数每被调用一次，都会产生一个新的执行上下文环境")]),t._v(" "),_("li",[t._v("函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域")])]),t._v(" "),_("h3",{attrs:{id:"this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),_("ul",[_("li",[t._v("在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了")]),t._v(" "),_("li",[t._v("因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。")]),t._v(" "),_("li",[t._v("如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。")]),t._v(" "),_("li",[t._v("如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。")]),t._v(" "),_("li",[t._v("如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。")])]),t._v(" "),_("h3",{attrs:{id:"执行上下午栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行上下午栈"}},[t._v("#")]),t._v(" 执行上下午栈")]),t._v(" "),_("ul",[_("li",[t._v("执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。")]),t._v(" "),_("li",[t._v("当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。")]),t._v(" "),_("li",[t._v("处于活动状态的执行上下文环境只有一个。")]),t._v(" "),_("li",[t._v("其实这是一个压栈出栈的过程——执行上下文栈。")])]),t._v(" "),_("h3",{attrs:{id:"作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),_("ul",[_("li",[t._v("javascript除了全局作用域之外，只有函数可以创建的作用域")]),t._v(" "),_("li",[t._v("我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式")]),t._v(" "),_("li",[t._v("作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的")]),t._v(" "),_("li",[t._v("作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突")]),t._v(" "),_("li",[t._v("作用域只是一个“地盘”，一个抽象的概念，其中没有变量。")]),t._v(" "),_("li",[t._v("要通过作用域对应的执行上下文环境来获取变量的值。")]),t._v(" "),_("li",[t._v("同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。")]),t._v(" "),_("li",[t._v("所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。")]),t._v(" "),_("li",[t._v("所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。")])]),t._v(" "),_("h3",{attrs:{id:"自由变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自由变量"}},[t._v("#")]),t._v(" 自由变量")]),t._v(" "),_("ul",[_("li",[t._v("要去创建这个函数的作用于取值，而不是“父作用域”")])]),t._v(" "),_("h3",{attrs:{id:"柯里化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[t._v("#")]),t._v(" 柯里化")]),t._v(" "),_("ul",[_("li",[t._v("柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。")]),t._v(" "),_("li",[t._v("接收单一参数，因为要携带不少信息，因此常常以回调函数的理由来解决。")]),t._v(" "),_("li",[t._v("将部分参数通过回调函数等方式传入函数中")]),t._v(" "),_("li",[t._v("返回一个新函数，用于处理所有的想要传入的参数")]),t._v(" "),_("li",[t._v("懒加载\n"),_("ul",[_("li",[t._v("什么是懒加载？\n"),_("ul",[_("li",[t._v("懒加载也就是延迟加载。")]),t._v(" "),_("li",[t._v("当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称占位图），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。")])])]),t._v(" "),_("li",[t._v("为什么要使用懒加载？\n"),_("ul",[_("li",[t._v("很多页面，内容很丰富，页面很长，图片较多。比如说各种商城页面。这些页面图片数量多，而且比较大，少说百来K，多则上兆。要是页面载入就一次性加载完毕。估计大家都会等到黄花变成黄花菜了。")])])]),t._v(" "),_("li",[t._v(".懒加载的原理是什么？\n"),_("ul",[_("li",[t._v("页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置；")])])]),t._v(" "),_("li",[t._v("懒加载的实现步骤？\n"),_("ul",[_("li",[t._v("首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。2)页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。3)在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。")])])]),t._v(" "),_("li",[t._v("懒加载的优点是什么？\n"),_("ul",[_("li",[t._v("页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好")])])])])]),t._v(" "),_("li",[t._v("预加载\n"),_("ul",[_("li",[t._v("什么是预加载？\n"),_("ul",[_("li",[t._v("提前加载图片，当用户需要查看时可直接从本地缓存中渲染")])])])])])]),t._v(" "),_("h3",{attrs:{id:""}},[_("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),_("img",{staticClass:"wechat-num",attrs:{src:"http://share.alihanniba.com/mac/490lq.png"}})])}),[],!1,null,null,null);v.default=i.exports}}]);